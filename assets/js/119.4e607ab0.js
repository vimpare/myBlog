(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{493:function(e,t,n){"use strict";n.r(t);var a=n(62),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"垃圾收集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集"}},[e._v("#")]),e._v(" 垃圾收集")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("js有自动垃圾收集机制\nJavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("标记清除")]),e._v(" "),n("p",[e._v("垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。\n而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。\n最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。")]),e._v(" "),n("p",[e._v("到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同")])]),e._v(" "),n("li",[n("p",[e._v("引用计数\n不太常见\n引用计数的含义是跟踪记录每个值被引用的次数\n但严重的问题：循环引用。引用次数不可能为0。需手动清除将值设为null,切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。\neg:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function problem(){    \n  var objectA = new Object();    \n  var objectB = new Object();    \n  objectA.someOtherObject = objectB;    \n  objectB.anotherObject = objectA;\n}\n")])])])]),e._v(" "),n("li",[n("p",[e._v("管理内存\n分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。\n通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。\n解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);