(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{512:function(n,e,t){"use strict";t.r(e);var a=t(62),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[n._v("#")]),n._v(" 代理模式")]),n._v(" "),t("p",[n._v("代理模式关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。\n替身对象对请求做出一些处理之后，再把请求转交给本体对象。")]),n._v(" "),t("h4",{attrs:{id:"虚拟代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟代理"}},[n._v("#")]),n._v(" 虚拟代理")]),n._v(" "),t("p",[n._v("在Web开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很适合使用虚拟代理。")]),n._v(" "),t("h4",{attrs:{id:"命令模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令模式"}},[n._v("#")]),n._v(" 命令模式")]),n._v(" "),t("p",[t("strong",[n._v("命令模式")]),n._v("最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得"),t("strong",[n._v("请求发送者和请求接收者能够消除彼此之间的耦合关系")]),n._v("\ncommand对象\n命令模式的例子——菜单程序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var setCommand = function (button, command) {\n    button.onclick = function () {\n        command.execute();\n    }\n};\nvar MenuBar = {\n    refresh: function () {\n        console.log('刷新菜单目录');\n    }\n};\nvar SubMenu = {\n    add: function () {\n        console.log('增加子菜单');\n    },\n    del: function () {\n        console.log('删除子菜单');\n    }\n};\nvar RefreshMenuBarCommand = function (receiver) {\n    this.receiver = receiver;\n};\nRefreshMenuBarCommand.prototype.execute = function () {\n    this.receiver.refresh();\n};\nvar AddSubMenuCommand = function (receiver) {\n    this.receiver = receiver;\n};\nAddSubMenuCommand.prototype.execute = function () {\n    this.receiver.add();\n};\nvar DelSubMenuCommand = function (receiver) {\n    this.receiver = receiver;\n};\nDelSubMenuCommand.prototype.execute = function () {\n    console.log('删除子菜单');\n};\nvar refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);\nvar addSubMenuCommand = new AddSubMenuCommand(SubMenu);\nvar delSubMenuCommand = new DelSubMenuCommand(SubMenu);\nsetCommand(button1, refreshMenuBarCommand);\nsetCommand(button2, addSubMenuCommand);\nsetCommand(button3, delSubMenuCommand);\n")])])]),t("p",[n._v("命令模式将过程式的请求调用封装在com-mand对象的execute方法里，通过封装方法调用，我们可以把运算块包装成形。command对象可以被四处传递，所以在调用命令的时候，客户（Client）不需要关心事情是如何进行的。")]),n._v(" "),t("p",[n._v("命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。\n撤销命令")])])}),[],!1,null,null,null);e.default=r.exports}}]);