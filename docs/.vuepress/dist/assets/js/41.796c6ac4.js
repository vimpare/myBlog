(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{543:function(e,a,n){"use strict";n.r(a);var s=n(62),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[n("strong",[e._v("调用函数")])]),e._v(" "),n("p",[e._v("http://docs.python.org/3/library/functions.html#abs")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('>>> abs(1, 2)\nTraceback (most recent call last):\nFile "<stdin>", line 1, in <module>\nTypeError: abs() takes exactly one argument (2 given)\n')])])])]),e._v(" "),n("li",[n("p",[e._v("如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息;")])])]),e._v(" "),n("p",[e._v("函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(">>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1\n")])])]),n("p",[n("strong",[e._v("定义函数")]),e._v("\n在Python中，定义一个函数要使用"),n("code",[e._v("def")]),e._v("语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用"),n("code",[e._v("return")]),e._v("语句返回。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("def my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n")])])]),n("ul",[n("li",[e._v("如果没有"),n("code",[e._v("return")]),e._v("语句，函数执行完毕后也会返回结果，只是结果为"),n("code",[e._v("None")]),e._v("。"),n("code",[e._v("return None")]),e._v("可以简写为"),n("code",[e._v("return")])])]),e._v(" "),n("p",[e._v("空函数:\n如果想定义一个什么事也不做的空函数，可以用pass语句：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("def nop():\n    pass\n")])])]),n("p",[e._v("参数检查:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError")])]),e._v(" "),n("li",[n("p",[e._v("如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(">>> my_abs('A')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 2, in my_abs\nTypeError: unorderable types: str() >= int()\n>>> abs('A')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: bad operand type for abs(): 'str'\n")])])]),n("p",[e._v("当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。")])]),e._v(" "),n("li",[n("p",[e._v("数据类型检查可以用内置函数"),n("code",[e._v("isinstance()")]),e._v("实现,"),n("code",[e._v("isinstance()")]),e._v(" 函数来判断一个对象是否是一个已知的类型，类似 "),n("code",[e._v("type()")]),e._v("。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("def my_abs(x):\n  if not isinstance(x, (int, float)):\n      raise TypeError('bad operand type')\n  if x >= 0:\n      return x\n  else:\n      return -x\n")])])])])]),e._v(" "),n("p",[e._v("返回多个值:Python的函数返回多值其实就是返回一个tuple")]),e._v(" "),n("p",[n("strong",[e._v("函数的参数")])]),e._v(" "),n("p",[e._v("位置参数:\n默认参数:\n可变参数:可变参数就是传入的参数个数是可变的,定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。\n"),n("code",[e._v("def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum")])]),e._v(" "),n("p",[e._v("关键字参数:关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(">>> person('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n")])])]),n("p",[e._v("命名关键字参数:")]),e._v(" "),n("p",[e._v("命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("def person(name, age, *, city, job):\n    print(name, age, city, job)\n")])])]),n("p",[n("strong",[e._v("导入模块")]),e._v(":\nimport 语句允许在当前运行的程序文件中使用模块中的代码")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("导入整个模块")]),e._v("\n要让函数是可导入的，得先创建模块。模块 是扩展名为.py的文件，包含要导入到程序中的代码。")]),e._v(" "),n("p",[n("code",[e._v("pizza.py")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def make_pizza(size, *toppings): \n    print("\\nMaking a " + str(size) + "-inch pizza with the following toppings:")\n    for topping in toppings: \n    print("- " + topping)\n')])])]),n("p",[e._v("pizza.py所在的目录中创建另一个名为"),n("code",[e._v("making_pizzas.py")]),e._v("的文件，这个文件导入刚创建的模块，再调用"),n("code",[e._v("make_pizza()")]),e._v("两次\n"),n("code",[e._v("making_pizzas.py")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import pizza \npizza.make_pizza(16, 'pepperoni') \npizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n")])])]),n("p",[e._v("只需编写一条"),n("code",[e._v("import")]),e._v(" 语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。\n如果你使用这种"),n("code",[e._v("import")]),e._v("语句导入了名为"),n("code",[e._v("module_name.py")]),e._v(" 的整个模块，就可使用下面的语法来使用其中任何一个函数：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("module_name.function_name()\n")])])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("导入模块中的特定函数")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("from module_name import function_name\n")])])]),n("p",[e._v("通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("from module_name import function_0, function_1, function_2\n")])])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("使用as给函数指定别名")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("from module_name import function_name as fn\n")])])]),n("p",[e._v("示例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("from pizza import make_pizza as mp \nmp(16, 'pepperoni') \nmp(12, 'mushrooms', 'green peppers', 'extra cheese')\n")])])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("使用as给模块指定别名")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import module_name as mn\n")])])]),n("p",[e._v("示例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import pizza as p \np.make_pizza(16, 'pepperoni') \np.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n")])])])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("导入模块中的所有函数")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("form module_name import *\n")])])]),n("p",[e._v("使用星号（* ）运算符可让Python导入模块中的所有函数\nimport 语句中的星号让Python将模块pizza 中的每个函数都复制到这个程序文件中。\n由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。\n然而，使用 并非自己编写的大型模块时，最好不要采用这种导入方法：\n如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函 数或变量，进而覆盖函数，而不是分别导入所有的函数。\n最佳的做法是，\n"),n("strong",[e._v("要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。")])])])])])}),[],!1,null,null,null);a.default=t.exports}}]);