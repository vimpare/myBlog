(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{509:function(n,e,s){"use strict";s.r(e);var r=s(62),t=Object(r.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("p",[s("strong",[n._v("职责链模式")])]),n._v(" "),s("p",[n._v("定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。")]),n._v(" "),s("p",[n._v("例：如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在N个人手上传递，才能最终到达售票员的手里。")]),n._v(" "),s("p",[n._v("最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。")]),n._v(" "),s("p",[n._v("这样一段代码")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\n// 500元订单\n\nvar order500 = function (orderType, pay, stock) {\n\n    if (orderType === 1 && pay === true) {\n\n        console.log('500元定金预购, 得到100优惠券');\n\n    } else {\n\n        order200(orderType, pay, stock); // 将请求传递给200元订单 \n\n    }\n\n}; // 200元订单\n\nvar order200 = function (orderType, pay, stock) {\n\n    if (orderType === 2 && pay === true) {\n\n        console.log('200元定金预购, 得到50优惠券');\n\n    } else {\n\n        orderNormal(orderType, pay, stock); // 将请求传递给普通订单    }};// 普通购买订单\n\n        var orderNormal = function (orderType, pay, stock) {\n\n            if (stock > 0) {\n\n                console.log('普通购买, 无优惠券');\n\n            } else {\n\n                console.log('手机库存不足');\n\n            }\n\n        };\n\n")])])]),s("p",[n._v("可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中，如果有天我们要增加300元预订或者去掉200元预订，意味着就必须改动这些业务函数内部。\n"),s("strong",[n._v("链条要灵活可拆分")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var order500 = function (orderType, pay, stock) {\n    if (orderType === 1 && pay === true) {\n        console.log('500元定金预购，得到100优惠券');\n    } else {\n        return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递    \n    }\n};\n// Chain.prototype.setNextSuccessor  指定在链中的下一个节点\n// Chain.prototype.passRequest  传递请求给某个节点\nvar Chain = function (fn) {\n    this.fn = fn;\n    this.successor = null;\n};\nChain.prototype.setNextSuccessor = function (successor) {\n    return this.successor = successor;\n};\nChain.prototype.passRequest = function () {\n    var ret = this.fn.apply(this, arguments);\n    if (ret === 'nextSuccessor') {\n        return this.successor && this.successor.passRequest.apply(this.successor, arguments);\n    }\n    return ret;\n};\nvar chainOrder500 = new Chain(order500);\nvar chainOrder200 = new Chain(order200);\nvar chainOrderNormal = new Chain(orderNormal);然后指定节点在职责链中的顺序：\nchainOrder500.setNextSuccessor(chainOrder200);\nchainOrder200.setNextSuccessor(chainOrderNormal);最后把请求传递给第一个节点：\nchainOrder500.passRequest(1, true, 500); // 输出：500元定金预购，得到100优惠券\n")])])]),s("p",[s("strong",[n._v("异步的职责链")]),n._v('\n当发起一个ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中passRequest，\n这时候让节点函数同步返回"nextSuccessor"已经没有意义了，所以要给Chain类再增加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的下一个节点：')]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("Chain.prototype.next = function () {\n    return this.successor && this.successor.passRequest.apply(this.successor, arguments);\n};\n\nvar fn1 = new Chain(function () {\n    console.log(1);\n    return 'nextSuccessor';\n});\nvar fn2 = new Chain(function () {\n    console.log(2);\n    var self = this;\n    setTimeout(function () {\n        self.next();\n    }, 1000);\n});\nvar fn3 = new Chain(function () {\n    console.log(3);\n});\nfn1.setNextSuccessor(fn2).setNextSuccessor(fn3);\nfn1.passRequest();\n")])])])])}),[],!1,null,null,null);e.default=t.exports}}]);