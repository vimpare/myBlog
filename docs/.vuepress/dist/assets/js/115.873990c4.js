(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{495:function(e,t,n){"use strict";n.r(t);var s=n(62),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"js中使用函数的高级方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js中使用函数的高级方法"}},[e._v("#")]),e._v(" js中使用函数的高级方法")]),e._v(" "),n("ul",[n("li",[e._v("安全的类型检测\njs内置的类型检测机制并非完全可靠；\n在任何值上调用object的原生toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function isFunction(value){\n  return Object.prototype.toString().call(value) == "[object Function]"\n}\n')])])]),n("ul",[n("li",[e._v("作用域安全的构造函数\n当构造函数使用普通函数方式不使用new操作符调用时，会出现构造函数内this错误，需使用作用域安全的构造函数；\n在进行更改前，首先确认this对象是正确类型的实例，如果不是，会创建新的实例并返回；")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Person(age,name){\n  if (this instanceof Person)}{\n    this.name=name\n    this.age=age\n  }else {\n    return new Person(age,name) //避免了全局对象上意外设置属性\n  }\n}\n")])])]),n("blockquote",[n("p",[e._v("构造函数窃取模式的继承？？？？")])]),e._v(" "),n("ul",[n("li",[e._v("惰性载入函数\n惰性载入表示函数执行的分支仅会发生一次；\n实现有两种方式：\n"),n("ul",[n("li",[e._v("函数调用时再处理函数。第一次调用时候，函数会被覆盖为另一个按合适方式执行的函数；")]),e._v(" "),n("li",[e._v("声明函数时就指定适当的函数。")])])]),e._v(" "),n("li",[e._v("函数绑定\n函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数；")])]),e._v(" "),n("blockquote",[n("p",[e._v("bind()传入this值的对象\n支持原生bind()方法的浏览器：ie9+ ff4+ Chrome;")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("函数科里化")])]),e._v(" "),n("li",[n("p",[e._v("防篡改对象")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("不可扩展对象\n调用object.preventExtensions方法后，就不能给对象添加属性和方法了。\nobject.isExtensible()可以确定对象是否扩展；")])]),e._v(" "),n("li",[n("p",[e._v("密封的对象\nobject.seal()\n密封对象不可扩展，属性不可删除\n使用object.isSealed()方法可以确定对象是否被密封了。")])]),e._v(" "),n("li",[n("p",[e._v("冻结的对象\nobject.freeze()\n既不可扩展，又密封，而且对象数据属性writable设置未false;\nobject.isFrozen()检测冻结对象;")])])])]),e._v(" "),n("li",[n("p",[e._v("高级定时器\n火狐中定时器的实现可以确定定时器过了多久执行，")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("setTimeout(function(diff){\n   if(diff>0){\n     //晚调用\n   }else if(diff<0){\n     //早调用\n   }else{\n     //调用及时\n   }\n})\n")])])]),n("p",[e._v("arguments.callee 属性包含当前正在执行的函数。\ncallee 是 arguments 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式 (也    称为“匿名函数”)内。")]),e._v(" "),n("p",[e._v("警告：在严格模式下，第5版 ECMAScript (ES5) 禁止使用 arguments.callee()。当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明\n采用setTimeout解决重复定时器问题")]),e._v(" "),n("ul",[n("li",[e._v("Yielding Processes 定时器数组分块技术")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" setTimeout(function(){\n   var item = array.shift();\n   process(item);\n   if (array.length > 0){\n    setTimeout(arguments.callee, 100);\n   }\n }, 100);\n\n")])])]),n("ul",[n("li",[n("p",[e._v("函数节流：\n某些代码不可以在没有间断的情况连续执行\n只要代码是周期性执行的，都应该使用节流")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function throttle(method,context){\n  clearTimeout(method.tId)\n  method.tId=setTimeout(function(){\n    method.call(context)\n  },100)\n  \n}\n")])])]),n("p",[e._v("要接受的参数：要执行的函数和在哪个作用域执行")])]),e._v(" "),n("li",[n("p",[e._v("自定义事件？？？？？没看，想回家过年。。。。。。。。。。。。。。。。。。。")])]),e._v(" "),n("li",[n("p",[e._v("拖放\n元素能够被拖放，必须是绝对定位的。\n。。。。。。。。。。。。。。。。。。")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);