(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{512:function(n,e,o){"use strict";o.r(e);var r=o(62),t=Object(r.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"模板方法模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式"}},[n._v("#")]),n._v(" 模板方法模式")]),n._v(" "),o("p",[n._v("模板方法模式由两部分结构组成，\n第一部分是抽象父类，\n第二部分是具体的实现子类。\n通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。")]),n._v(" "),o("p",[n._v("模板方法模式是一种严重依赖抽象类的设计模式。")]),n._v(" "),o("p",[o("strong",[n._v("咖啡与茶")]),n._v("是一个经典的例子，经常用来讲解模板方法模式")]),n._v(" "),o("p",[n._v("继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口")]),n._v(" "),o("p",[n._v("当子类继承了这个抽象类时，必须重写父类的抽象方法。")]),n._v(" "),o("p",[n._v("JavaScript并没有从语法层面提供对抽象类的支持 ,我们没有办法保证子类会重写父类中的“抽象方法”。")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("•第1种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。   \n\n•第2种方案是让Beverage.prototype.brew等方法直接抛出一个异常，如果因为粗心忘记编写Coffee.prototype.brew方法，那么至少我们会在程序运行时得到一个错误\n")])])]),o("p",[o("strong",[n._v("钩子方法")]),n._v("\n钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。")]),n._v(" "),o("p",[o("strong",[n._v("不使用继承，使用高阶函数方式")]),n._v("：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("var Beverage = function (param) {\n    var boilWater = function () {\n        console.log('把水煮沸');\n    };\n    var brew = param.brew || function () {\n            throw new Error('必须传递brew方法');\n        };\n    var pourInCup = param.pourInCup || function () {\n            throw new Error('必须传递pourInCup方法');\n        };\n    var addCondiments = param.addCondiments || function () {\n            throw new Error('必须传递addCondiments方法');\n        };\n    var F = function () {};\n    F.prototype.init = function () {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    };\n    return F;\n};\nvar Coffee = Beverage({\n    brew: function () {\n        console.log('用沸水冲泡咖啡');\n    },\n    pourInCup: function () {\n        console.log('把咖啡倒进杯子');\n    },\n    addCondiments: function () {\n        console.log('加糖和牛奶');\n    }\n});\nvar Tea = Beverage({\n    brew: function () {\n        console.log('用沸水浸泡茶叶');\n    },\n    pourInCup: function () {\n        console.log('把茶倒进杯子');\n    },\n    addCondiments: function () {\n        console.log('加柠檬');\n    }\n});\nvar coffee = new Coffee();\ncoffee.init();\nvar tea = new Tea();\ntea.init();\n")])])])])}),[],!1,null,null,null);e.default=t.exports}}]);