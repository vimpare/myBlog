(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{535:function(e,n,s){"use strict";s.r(n);var t=s(62),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("promise的功能是可以将复杂的异步处理轻松地进行模式化，\nAPI:\nPromise类似于 XMLHttpRequest，从构造函数 Promise 来创建一个新建新promise对象作为接口。")]),e._v(" "),s("p",[e._v("要想创建一个promise对象、可以使用new来调用Promise的构造器来进行实例化。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var promise = new Promise(function(resolve, reject) {\n    // 异步处理\n    // 处理结束后、调用resolve 或 reject\n});\n")])])]),s("p",[e._v("对通过new生成的promise对象为了设置其值在 resolve(成功) / reject(失败)时调用的回调函数 可以使用promise.then() 实例方法:\n"),s("code",[e._v("promise.then(onFulfilled, onRejected)")])]),e._v(" "),s("p",[e._v("resolve(成功)时\nonFulfilled 会被调用")]),e._v(" "),s("p",[e._v("reject(失败)时\nonRejected 会被调用")]),e._v(" "),s("p",[e._v("onFulfilled、onRejected 两个都为可选参数。")]),e._v(" "),s("p",[e._v("promise.then 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 "),s("code",[e._v("promise.then(undefined, onRejected)")]),e._v(" 这种方式，只指定reject时的回调函数即可。 不过这种情况下 "),s("code",[e._v("promise.catch(onRejected)")]),e._v(" 应该是个更好的选择")]),e._v(" "),s("p",[e._v("workflow:工作流程")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function asyncFunction() {\n    (1)\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve('荣荣荣荣');\n        }, 16);\n    });\n}\n(2)\nasyncFunction().then(function (value) {\n      // => 'Async Hello world'\n}).catch(function (error) {\n    console.log(error,222);\n});\n")])])]),s("p",[e._v("asyncFunction 这个函数会返回promise对象， 对于这个promise对象，我们调用它的 then 方法来设置resolve后的回调函数， catch 方法来设置发生错误时的回调函数。\n等同：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("asyncFunction().then(function (value) {\n    console.log(value);\n}, function (error) {\n    console.log(error);\n});\n")])])]),s("p",[e._v("Promise的状态:")]),e._v(" "),e._v('" - Fulfilled extra-class">'),s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('resolve(成功)时。此时会调用 onFulfilled\n\n"has-rejection" - Rejected\nreject(失败)时。此时会调用 onRejected\n\n"unresolved" - Pending\n既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等\n')])]),e._v(" "),s("p",[e._v("用Promise来通过异步处理方式来获取XMLHttpRequest(XHR)的数据")]),e._v(" "),s("p",[e._v("静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式")]),e._v(" "),s("p",[e._v("比如 "),s("code",[e._v("Promise.resolve(42);")]),e._v(" 可以认为是以下代码的语法糖。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("new Promise(function(resolve){\n    resolve(42);\n});\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.resolve(42).then(function(value){\n    console.log(value);\n});\n")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);